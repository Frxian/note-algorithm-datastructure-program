# Note

## Data structures

### Fundamental data structures

The choice of `representation of data` must always be taken in the light of the `operations` that are to be performed on the data.

#### Concept of data type

1. If `data type` is known to a compiler, so-called `dynamic storage allocation` can be avoided. This is very often the key to an `efficient realization` of an algorithm.

##### The primary characteristics of the concept of type

* A `data type` determines the set of values to which a `constant` belongs, or which may be assumed by a `variable` or an `expression`, or which may be `generated` by an `operator or a function`.
* The type of a value denoted by a constant, variable, or expression may be derived from its form or its `declaration` without the necessity of executing the computational process.
* Each operator or function expects `arguments of a fixed type` and yields a `result of a fixed type`. If an operator admits arguments of several types (e.g., + is used for addition of both integers and real numbers), then the type of the result can be determined from specific language rules.

#### Primitive data type

A new, primitive type is definable by `enumerating the distinct values` belonging to it. Such a type is called an *enumeration type*. Its definition has the form: 

``` mathematica
TYPE T=(c1,c2,...,cn)
 T is the new type identifier, and the ci are the new constant identifiers.
```

#### The array structure

The definition of an array type `T` specifies both a base type `T0` and an index type `I`.

```pseudocode
type T = array[I] of T0
```

##### Representation of array structure

* A `representation` of an array structure is a mapping of `the (abstract) array` with components of type T onto the `store` which is `an array` with components of type `BYTE`.  The mapping function:

```pseudocode
i = i0 + j*s
```

â€‹	If s is not a `whole number` (and this is the normal case), then s is usually rounded up to the next `larger integer S`. Each array component then occupies S words, whereby S-s words are left `unused` (see Figs. 1.5 and 1.6). `Rounding up of the number of words` needed to the next whole number is called *padding*. 

* The relevant considerations of padding
  * Padding decreases storage utilization.
  * Omission of padding may necessitate inefficient partial word access.
  * Partial word access may cause the code (compiled program) to expand and therefore to counteract the gain obtained by omission of padding.

### The file or sequence

**The difference with array**

* This `structure` looks exactly like the `array`. The `essential difference` is that in the case of the array the number of elements is `fixed` by the array's declaration, whereas for the sequence it is left `open`. 
* A sequence is inspected by strictly proceeding from one element to its `immediate successor`, and that it is generated by repeatedly `appending an element` at its end. 
* `Arrays and records` are `random access` structures. They are used when located in primary, random-access store.
* `Sequences` are used to access data on `secondary, sequential-access stores`, such as disks and tapes.

**The advantage of usage**

* The possibility to use effective `buffering techniques` when moving data to or from secondary storage devices.

#### Elementary file operations

* To `write` and `read` a file, we need an object called `rider`, which itself `connected` with a `file(sequence)`, and which implements a certain `access mechanism`.
* 